/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.13.0
 */

import { SignKeyPair as KeyPair } from "tweetnacl";
import BN from "bn.js";
import { Struct } from "superstruct";
import { Client as RpcWebSocketClient } from "rpc-websockets";
import RpcClient from "jayson/lib/client/browser";
import { IWSRequestParams } from "rpc-websockets/dist/lib/client";
import * as BufferLayout from "buffer-layout";

/**
 * Maximum length of derived pubkey seed
 */
declare var MAX_SEED_LENGTH: any; // 32
/**
 * A public key
 */
declare class PublicKey {
  /**
   * @internal
   */
  _bn: BN;

  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  constructor(
    value: number | string | Buffer | Uint8Array | Array<number>
  ): this;

  /**
   * Checks if two publicKeys are equal
   */
  equals(publicKey: PublicKey): boolean;

  /**
   * Return the base-58 representation of the public key
   */
  toBase58(): string;

  /**
   * Return the Buffer representation of the public key
   */
  toBuffer(): Buffer;

  /**
   * Return the base-58 representation of the public key
   */
  toString(): string;

  /**
   * Derive a public key from another key, a seed, and a program ID.
   */
  static createWithSeed(
    fromPublicKey: PublicKey,
    seed: string,
    programId: PublicKey
  ): Promise<PublicKey>;

  /**
   * Derive a program address from seeds and a program ID.
   */
  static createProgramAddress(
    seeds: Array<Buffer | Uint8Array>,
    programId: PublicKey
  ): Promise<PublicKey>;

  /**
   * Find a valid program address
   *
   * Valid program addresses must fall off the ed25519 curve.  This function
   * iterates a nonce until it finds one that when combined with the seeds
   * results in a valid program address.
   */
  static findProgramAddress(
    seeds: Array<Buffer | Uint8Array>,
    programId: PublicKey
  ): Promise<[PublicKey, number]>;
}
/**
 * An account key pair (public and secret keys).
 */
declare class Account {
  /**
   * @internal
   */
  _keypair: KeyPair;

  /**
   * Create a new Account object
   *
   * If the secretKey parameter is not provided a new key pair is randomly
   * created for the account
   * @param secretKey Secret key for the account
   */
  constructor(secretKey?: Buffer | Uint8Array | Array<number>): this;

  /**
   * The public key for this account
   */
  publicKey: PublicKey;

  /**
   * The **unencrypted** secret key for this account
   */
  secretKey: Buffer;
}
/**
 * Blockhash as Base58 string.
 */
declare type Blockhash = string;
declare var BPF_LOADER_DEPRECATED_PROGRAM_ID: PublicKey;
/**
 * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11
 * @internal
 */
declare var FeeCalculatorLayout: any;
/**
 * Calculator for transaction fees.
 */
declare interface FeeCalculator {
  /**
   * Cost in lamports to validate a signature.
   */
  lamportsPerSignature: number;
}
declare var NONCE_ACCOUNT_LENGTH: any;
declare type NonceAccountArgs = {
  authorizedPubkey: PublicKey,
  nonce: Blockhash,
  feeCalculator: FeeCalculator,
  ...
};
/**
 * NonceAccount class
 */
declare class NonceAccount {
  authorizedPubkey: PublicKey;
  nonce: Blockhash;
  feeCalculator: FeeCalculator;

  /**
   * @internal
   */
  constructor(args: NonceAccountArgs): this;

  /**
   * Deserialize NonceAccount from the account data.
   * @param buffer account data
   * @return NonceAccount
   */
  static fromAccountData(
    buffer: Buffer | Uint8Array | Array<number>
  ): NonceAccount;
}
/**
 * The message header, identifying signed and read-only account
 * @typedef MessageHeader
 */
declare type MessageHeader = {
  numRequiredSignatures: number,
  numReadonlySignedAccounts: number,
  numReadonlyUnsignedAccounts: number,
  ...
};
/**
 * An instruction to execute by a program
 * @typedef CompiledInstruction
 */
declare type CompiledInstruction = {
  programIdIndex: number,
  accounts: number[],
  data: string,
  ...
};
/**
 * Message constructor arguments
 * @typedef MessageArgs
 */
declare type MessageArgs = {
  header: MessageHeader,
  accountKeys: string[],
  recentBlockhash: Blockhash,
  instructions: CompiledInstruction[],
  ...
};
/**
 * List of instructions to be processed atomically
 */
declare class Message {
  header: MessageHeader;
  accountKeys: PublicKey[];
  recentBlockhash: Blockhash;
  instructions: CompiledInstruction[];
  constructor(args: MessageArgs): this;
  isAccountWritable(index: number): boolean;
  serialize(): Buffer;

  /**
   * Decode a compiled message into a Message object.
   */
  static from(buffer: Buffer | Uint8Array | Array<number>): Message;
}
/**
 * @typedef {string} TransactionSignature
 */
declare type TransactionSignature = string;
/**
 * Maximum over-the-wire size of a Transaction
 *
 * 1280 is IPv6 minimum MTU
 * 40 bytes is the size of the IPv6 header
 * 8 bytes is the size of the fragment header
 */
declare var PACKET_DATA_SIZE: number;
/**
 * Account metadata used to define instructions
 * @typedef AccountMeta
 */
declare type AccountMeta = {
  pubkey: PublicKey,
  isSigner: boolean,
  isWritable: boolean,
  ...
};
/**
 * List of TransactionInstruction object fields that may be initialized at construction
 * @typedef TransactionInstructionCtorFields
 */
declare type TransactionInstructionCtorFields = {
  keys: Array<AccountMeta>,
  programId: PublicKey,
  data?: Buffer,
  ...
};
/**
 * Configuration object for Transaction.serialize()
 * @typedef SerializeConfig
 */
declare type SerializeConfig = {
  requireAllSignatures?: boolean,
  verifySignatures?: boolean,
  ...
};
/**
 * Transaction Instruction class
 */
declare class TransactionInstruction {
  /**
   * Public keys to include in this transaction
   * Boolean represents whether this pubkey needs to sign the transaction
   */
  keys: Array<AccountMeta>;

  /**
   * Program Id to execute
   */
  programId: PublicKey;

  /**
   * Program input
   */
  data: Buffer;
  constructor(opts: TransactionInstructionCtorFields): this;
}
/**
 * @internal
 */
declare type SignaturePubkeyPair = {
  signature: Buffer | null,
  publicKey: PublicKey,
  ...
};
/**
 * List of Transaction object fields that may be initialized at construction
 * @typedef TransactionCtorFields
 */
declare type TransactionCtorFields = {
  recentBlockhash?: Blockhash | null,
  nonceInfo?: NonceInformation | null,
  feePayer?: PublicKey | null,
  signatures?: Array<SignaturePubkeyPair>,
  ...
};
/**
 * NonceInformation to be used to build a Transaction.
 * @typedef NonceInformation
 */
declare type NonceInformation = {
  nonce: Blockhash,
  nonceInstruction: TransactionInstruction,
  ...
};
/**
 * Transaction class
 */
declare class Transaction {
  /**
   * Signatures for the transaction.  Typically created by invoking the
   * `sign()` method
   */
  signatures: Array<SignaturePubkeyPair>;

  /**
   * The first (payer) Transaction signature
   */
  signature: Buffer | null;

  /**
   * The transaction fee payer
   */
  feePayer?: PublicKey;

  /**
   * The instructions to atomically execute
   */
  instructions: Array<TransactionInstruction>;

  /**
   * A recent transaction id. Must be populated by the caller
   */
  recentBlockhash?: Blockhash;

  /**
   * Optional Nonce information. If populated, transaction will use a durable
   * Nonce hash instead of a recentBlockhash. Must be populated by the caller
   */
  nonceInfo?: NonceInformation;

  /**
   * Construct an empty Transaction
   */
  constructor(opts?: TransactionCtorFields): this;

  /**
   * Add one or more instructions to this Transaction
   */
  add(
    ...items: Array<
      Transaction | TransactionInstruction | TransactionInstructionCtorFields
    >
  ): Transaction;

  /**
   * Compile transaction data
   */
  compileMessage(): Message;

  /**
   * @internal
   */
  _compile(): Message;

  /**
   * Get a buffer of the Transaction data that need to be covered by signatures
   */
  serializeMessage(): Buffer;

  /**
   * Specify the public keys which will be used to sign the Transaction.
   * The first signer will be used as the transaction fee payer account.
   *
   * Signatures can be added with either `partialSign` or `addSignature`
   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
   * specified and it can be set in the Transaction constructor or with the
   * `feePayer` property.
   */
  setSigners(...signers: Array<PublicKey>): void;

  /**
   * Sign the Transaction with the specified accounts. Multiple signatures may
   * be applied to a Transaction. The first signature is considered "primary"
   * and is used identify and confirm transactions.
   *
   * If the Transaction `feePayer` is not set, the first signer will be used
   * as the transaction fee payer account.
   *
   * Transaction fields should not be modified after the first call to `sign`,
   * as doing so may invalidate the signature and cause the Transaction to be
   * rejected.
   *
   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
   */
  sign(...signers: Array<Account>): void;

  /**
   * Partially sign a transaction with the specified accounts. All accounts must
   * correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * All the caveats from the `sign` method apply to `partialSign`
   */
  partialSign(...signers: Array<Account>): void;

  /**
   * @internal
   */
  _partialSign(message: Message, ...signers: Array<Account>): void;

  /**
   * Add an externally created signature to a transaction. The public key
   * must correspond to either the fee payer or a signer account in the transaction
   * instructions.
   */
  addSignature(pubkey: PublicKey, signature: Buffer): void;

  /**
   * @internal
   */
  _addSignature(pubkey: PublicKey, signature: Buffer): void;

  /**
   * Verify signatures of a complete, signed Transaction
   */
  verifySignatures(): boolean;

  /**
   * @internal
   */
  _verifySignatures(signData: Buffer, requireAllSignatures: boolean): boolean;

  /**
   * Serialize the Transaction in the wire format.
   */
  serialize(config?: SerializeConfig): Buffer;

  /**
   * @internal
   */
  _serialize(signData: Buffer): Buffer;

  /**
   * Deprecated method
   * @internal
   */
  keys: Array<PublicKey>;

  /**
   * Deprecated method
   * @internal
   */
  programId: PublicKey;

  /**
   * Deprecated method
   * @internal
   */
  data: Buffer;

  /**
   * Parse a wire transaction into a Transaction object.
   */
  static from(buffer: Buffer | Uint8Array | Array<number>): Transaction;

  /**
   * Populate Transaction object from message and signatures
   */
  static populate(message: Message, signatures: Array<string>): Transaction;
}
/**
 * Attempt to use a recent blockhash for up to 30 seconds
 * @internal
 */
declare var BLOCKHASH_CACHE_TIMEOUT_MS: number;
declare type RpcRequest = (methodName: string, args: Array<any>) => any;
declare type RpcBatchRequest = (requests: RpcParams[]) => any;
/**
 * @internal
 */
declare type RpcParams = {
  methodName: string,
  args: Array<any>,
  ...
};
declare type TokenAccountsFilter =
  | {
      mint: PublicKey,
      ...
    }
  | {
      programId: PublicKey,
      ...
    };
/**
 * Extra contextual information for RPC responses
 */
declare type Context = {
  slot: number,
  ...
};
/**
 * Options for sending transactions
 */
declare type SendOptions = {
  /**
   * disable transaction verification step
   */
  skipPreflight?: boolean,

  /**
   * preflight commitment level
   */
  preflightCommitment?: Commitment,
  ...
};
/**
 * Options for confirming transactions
 */
declare type ConfirmOptions = {
  /**
   * disable transaction verification step
   */
  skipPreflight?: boolean,

  /**
   * desired commitment level
   */
  commitment?: Commitment,

  /**
   * preflight commitment level
   */
  preflightCommitment?: Commitment,
  ...
};
/**
 * Options for getConfirmedSignaturesForAddress2
 * @typedef {Object} ConfirmedSignaturesForAddress2Options
 */
declare type ConfirmedSignaturesForAddress2Options = {
  /**
   * Start searching backwards from this transaction signature.
   * @remark If not provided the search starts from the highest max confirmed block.
   */
  before?: TransactionSignature,

  /**
   * Maximum transaction signatures to return (between 1 and 1,000, default: 1,000).
   */
  limit?: number,
  ...
};
/**
 * RPC Response with extra contextual information
 */
declare type RpcResponseAndContext<T> = {
  /**
   * response context
   */
  context: Context,

  /**
   * response value
   */
  value: T,
  ...
};
/**
 * The level of commitment desired when querying state
 * <pre>
 *   'processed': Query the most recent block which has reached 1 confirmation by the connected node
 *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster
 *   'finalized': Query the most recent block which has been finalized by the cluster
 * </pre>
 * @typedef {"processed" | "confirmed" | "finalized"} Commitment
 */
declare type Commitment =
  | "processed"
  | "confirmed"
  | "finalized"
  | "recent"
  | "single"
  | "singleGossip"
  | "root"
  | "max";
/**
 * Filter for largest accounts query
 * <pre>
 *   'circulating':    Return the largest accounts that are part of the circulating supply
 *   'nonCirculating': Return the largest accounts that are not part of the circulating supply
 * </pre>
 * @typedef {"circulating" | "nonCirculating"} LargestAccountsFilter
 */
declare type LargestAccountsFilter = "circulating" | "nonCirculating";
/**
 * Configuration object for changing `getLargestAccounts` query behavior
 * @typedef GetLargestAccountsConfig
 */
declare type GetLargestAccountsConfig = {
  commitment?: Commitment,
  filter?: LargestAccountsFilter,
  ...
};
/**
 * Configuration object for changing query behavior
 * @typedef SignatureStatusConfig
 */
declare type SignatureStatusConfig = {
  searchTransactionHistory: boolean,
  ...
};
/**
 * Information describing a cluster node
 * @typedef ContactInfo
 */
declare type ContactInfo = {
  pubkey: string,
  gossip: string | null,
  tpu: string | null,
  rpc: string | null,
  version: string | null,
  ...
};
/**
 * Information describing a vote account
 * @typedef VoteAccountInfo
 */
declare type VoteAccountInfo = {
  votePubkey: string,
  nodePubkey: string,
  activatedStake: number,
  epochVoteAccount: boolean,
  epochCredits: Array<[number, number, number]>,
  commission: number,
  lastVote: number,
  ...
};
/**
 * A collection of cluster vote accounts
 * @typedef VoteAccountStatus
 */
declare type VoteAccountStatus = {
  current: Array<VoteAccountInfo>,
  delinquent: Array<VoteAccountInfo>,
  ...
};
/**
 * Network Inflation
 * (see https://docs.solana.com/implemented-proposals/ed_overview)
 * @typedef InflationGovernor
 */
declare type InflationGovernor = {
  foundation: number,
  foundationTerm: number,
  initial: number,
  taper: number,
  terminal: number,
  ...
};
/**
 * Information about the current epoch
 * @typedef EpochInfo
 */
declare type EpochInfo = {
  epoch: number,
  slotIndex: number,
  slotsInEpoch: number,
  absoluteSlot: number,
  blockHeight?: number,
  transactionCount?: number,
  ...
};
/**
 * Epoch schedule
 * (see https://docs.solana.com/terminology#epoch)
 * @typedef EpochSchedule
 */
declare type EpochSchedule = {
  slotsPerEpoch: number,
  leaderScheduleSlotOffset: number,
  warmup: boolean,
  firstNormalEpoch: number,
  firstNormalSlot: number,
  ...
};
/**
 * Leader schedule
 * (see https://docs.solana.com/terminology#leader-schedule)
 * @typedef {Object} LeaderSchedule
 */
declare type LeaderSchedule = {
  [address: string]: number[],
  ...
};
declare type Version = {
  "solana-core": string,
  "feature-set"?: number,
  ...
};
declare type SimulatedTransactionResponse = {
  err: TransactionError | string | null,
  logs: Array<string> | null,
  ...
};
declare type ParsedInnerInstruction = {
  index: number,
  instructions: (ParsedInstruction | PartiallyDecodedInstruction)[],
  ...
};
declare type TokenBalance = {
  accountIndex: number,
  mint: string,
  uiTokenAmount: TokenAmount,
  ...
};
/**
 * Metadata for a parsed confirmed transaction on the ledger
 * @typedef ParsedConfirmedTransactionMeta
 */
declare type ParsedConfirmedTransactionMeta = {
  fee: number,
  innerInstructions?: ParsedInnerInstruction[] | null,
  preBalances: Array<number>,
  postBalances: Array<number>,
  logMessages?: Array<string> | null,
  preTokenBalances?: Array<TokenBalance> | null,
  postTokenBalances?: Array<TokenBalance> | null,
  err: TransactionError | null,
  ...
};
declare type CompiledInnerInstruction = {
  index: number,
  instructions: CompiledInstruction[],
  ...
};
/**
 * Metadata for a confirmed transaction on the ledger
 * @typedef ConfirmedTransactionMeta
 */
declare type ConfirmedTransactionMeta = {
  fee: number,
  innerInstructions?: CompiledInnerInstruction[] | null,
  preBalances: Array<number>,
  postBalances: Array<number>,
  logMessages?: Array<string> | null,
  preTokenBalances?: Array<TokenBalance> | null,
  postTokenBalances?: Array<TokenBalance> | null,
  err: TransactionError | null,
  ...
};
/**
 * A confirmed transaction on the ledger
 * @typedef ConfirmedTransaction
 */
declare type ConfirmedTransaction = {
  slot: number,
  transaction: Transaction,
  meta: ConfirmedTransactionMeta | null,
  blockTime?: number | null,
  ...
};
/**
 * A partially decoded transaction instruction
 */
declare type PartiallyDecodedInstruction = {
  /**
   * Program id called by this instruction
   */
  programId: PublicKey,

  /**
   * Public keys of accounts passed to this instruction
   */
  accounts: Array<PublicKey>,

  /**
   * Raw base-58 instruction data
   */
  data: string,
  ...
};
/**
 * A parsed transaction message account
 * @typedef ParsedMessageAccount
 */
declare type ParsedMessageAccount = {
  pubkey: PublicKey,
  signer: boolean,
  writable: boolean,
  ...
};
/**
 * A parsed transaction instruction
 * @typedef ParsedInstruction
 */
declare type ParsedInstruction = {
  program: string,
  programId: PublicKey,
  parsed: any,
  ...
};
/**
 * A parsed transaction message
 * @typedef ParsedMessage
 */
declare type ParsedMessage = {
  accountKeys: ParsedMessageAccount[],
  instructions: (ParsedInstruction | PartiallyDecodedInstruction)[],
  recentBlockhash: string,
  ...
};
/**
 * A parsed transaction
 * @typedef ParsedTransaction
 */
declare type ParsedTransaction = {
  signatures: Array<string>,
  message: ParsedMessage,
  ...
};
/**
 * A parsed and confirmed transaction on the ledger
 * @typedef ParsedConfirmedTransaction
 */
declare type ParsedConfirmedTransaction = {
  slot: number,
  transaction: ParsedTransaction,
  meta: ParsedConfirmedTransactionMeta | null,
  blockTime?: number | null,
  ...
};
/**
 * A ConfirmedBlock on the ledger
 * @typedef ConfirmedBlock
 */
declare type ConfirmedBlock = {
  blockhash: Blockhash,
  previousBlockhash: Blockhash,
  parentSlot: number,
  transactions: Array<{
    transaction: Transaction,
    meta: ConfirmedTransactionMeta | null,
    ...
  }>,
  rewards?: Array<{
    pubkey: string,
    lamports: number,
    postBalance: number | null,
    rewardType: string | null,
    ...
  }>,
  blockTime: number | null,
  ...
};
/**
 * A performance sample
 * @typedef PerfSample
 */
declare type PerfSample = {
  slot: number,
  numTransactions: number,
  numSlots: number,
  samplePeriodSecs: number,
  ...
};
/**
 * Supply
 * @typedef Supply
 */
declare type Supply = {
  total: number,
  circulating: number,
  nonCirculating: number,
  nonCirculatingAccounts: Array<PublicKey>,
  ...
};
/**
 * Token amount object which returns a token amount in different formats
 * for various client use cases.
 * @typedef TokenAmount
 */
declare type TokenAmount = {
  amount: string,
  decimals: number,
  uiAmount: number | null,
  uiAmountString?: string,
  ...
};
/**
 * Token address and balance.
 * @typedef TokenAccountBalancePair
 */
declare type TokenAccountBalancePair = {
  address: PublicKey,
  amount: string,
  decimals: number,
  uiAmount: number | null,
  uiAmountString?: string,
  ...
};
/**
 * Pair of an account address and its balance
 * @typedef AccountBalancePair
 */
declare type AccountBalancePair = {
  address: PublicKey,
  lamports: number,
  ...
};
/**
 * Expected JSON RPC response for the "getConfirmedBlock" message
 */
declare var GetConfirmedBlockRpcResult: Struct<
  | {
      jsonrpc: "2.0",
      id: string,
      result: {
        blockTime: number | null,
        blockhash: string,
        previousBlockhash: string,
        parentSlot: number,
        transactions: {
          transaction: Transaction,
          meta: {
            err: { ... } | null,
            fee: number,
            preBalances: number[],
            postBalances: number[],
            innerInstructions?:
              | {
                  instructions: {
                    programIdIndex: number,
                    accounts: number[],
                    data: string,
                    ...
                  }[],
                  index: number,
                  ...
                }[]
              | null
              | void,
            logMessages?: string[] | null | void,
            preTokenBalances?:
              | {
                  accountIndex: number,
                  mint: string,
                  uiTokenAmount: {
                    amount: string,
                    uiAmount: number | null,
                    decimals: number,
                    uiAmountString?: string | void,
                    ...
                  },
                  ...
                }[]
              | null
              | void,
            postTokenBalances?:
              | {
                  accountIndex: number,
                  mint: string,
                  uiTokenAmount: {
                    amount: string,
                    uiAmount: number | null,
                    decimals: number,
                    uiAmountString?: string | void,
                    ...
                  },
                  ...
                }[]
              | null
              | void,
            ...
          } | null,
          ...
        }[],
        rewards?:
          | {
              pubkey: string,
              lamports: number,
              postBalance: number | null,
              rewardType: string | null,
              ...
            }[]
          | void,
        ...
      } | null,
      ...
    }
  | {
      jsonrpc: "2.0",
      id: string,
      error: {
        code: mixed,
        message: string,
        data?: any,
        ...
      },
      ...
    },
  null
>;
/**
 * Information about the latest slot being processed by a node
 * @typedef SlotInfo
 */
declare type SlotInfo = {
  slot: number,
  parent: number,
  root: number,
  ...
};
/**
 * Parsed account data
 * @typedef ParsedAccountData
 */
declare type ParsedAccountData = {
  program: string,
  parsed: any,
  space: number,
  ...
};
/**
 * Stake Activation data
 * @typedef StakeActivationData
 */
declare type StakeActivationData = {
  state: "active" | "inactive" | "activating" | "deactivating",
  active: number,
  inactive: number,
  ...
};
/**
 * Information describing an account
 * @typedef AccountInfo
 */
declare type AccountInfo<T> = {
  executable: boolean,
  owner: PublicKey,
  lamports: number,
  data: T,
  ...
};
/**
 * Account information identified by pubkey
 * @typedef KeyedAccountInfo
 */
declare type KeyedAccountInfo = {
  accountId: PublicKey,
  accountInfo: AccountInfo<Buffer>,
  ...
};
/**
 * Callback function for account change notifications
 */
declare type AccountChangeCallback = (
  accountInfo: AccountInfo<Buffer>,
  context: Context
) => void;
/**
 * @internal
 */
declare type SubscriptionId = "subscribing" | number;
/**
 * @internal
 */
declare type AccountSubscriptionInfo = {
  publicKey: string,
  callback: AccountChangeCallback,
  commitment?: Commitment,
  subscriptionId: SubscriptionId | null,
  ...
};
/**
 * Callback function for program account change notifications
 */
declare type ProgramAccountChangeCallback = (
  keyedAccountInfo: KeyedAccountInfo,
  context: Context
) => void;
/**
 * @internal
 */
declare type ProgramAccountSubscriptionInfo = {
  programId: string,
  callback: ProgramAccountChangeCallback,
  commitment?: Commitment,
  subscriptionId: SubscriptionId | null,
  ...
};
/**
 * Callback function for slot change notifications
 */
declare type SlotChangeCallback = (slotInfo: SlotInfo) => void;
/**
 * @internal
 */
declare type SlotSubscriptionInfo = {
  callback: SlotChangeCallback,
  subscriptionId: SubscriptionId | null,
  ...
};
/**
 * Callback function for signature status notifications
 */
declare type SignatureResultCallback = (
  signatureResult: SignatureResult,
  context: Context
) => void;
/**
 * Signature status notification with transaction result
 */
declare type SignatureStatusNotification = {
  type: "status",
  result: SignatureResult,
  ...
};
/**
 * Signature received notification
 */
declare type SignatureReceivedNotification = {
  type: "received",
  ...
};
/**
 * Callback function for signature notifications
 */
declare type SignatureSubscriptionCallback = (
  notification: SignatureStatusNotification | SignatureReceivedNotification,
  context: Context
) => void;
/**
 * Signature subscription options
 */
declare type SignatureSubscriptionOptions = {
  commitment?: Commitment,
  enableReceivedNotification?: boolean,
  ...
};
/**
 * @internal
 */
declare type SignatureSubscriptionInfo = {
  signature: TransactionSignature,
  callback: SignatureSubscriptionCallback,
  options?: SignatureSubscriptionOptions,
  subscriptionId: SubscriptionId | null,
  ...
};
/**
 * Callback function for root change notifications
 */
declare type RootChangeCallback = (root: number) => void;
/**
 * @internal
 */
declare type RootSubscriptionInfo = {
  callback: RootChangeCallback,
  subscriptionId: SubscriptionId | null,
  ...
};
/**
 * Logs result.
 * @typedef {Object} Logs
 */
declare type Logs = {
  err: TransactionError | null,
  logs: string[],
  signature: string,
  ...
};
/**
 * Filter for log subscriptions.
 */
declare type LogsFilter = PublicKey | "all" | "allWithVotes";
/**
 * Callback function for log notifications.
 */
declare type LogsCallback = (logs: Logs, ctx: Context) => void;
/**
 * @private
 */
declare type LogsSubscriptionInfo = {
  callback: LogsCallback,
  filter: LogsFilter,
  subscriptionId: SubscriptionId | null,
  commitment?: Commitment,
  ...
};
/**
 * Signature result
 * @typedef {Object} SignatureResult
 */
declare type SignatureResult = {
  err: TransactionError | null,
  ...
};
/**
 * Transaction error
 * @typedef {Object} TransactionError
 */
declare type TransactionError = { ... };
/**
 * Transaction confirmation status
 * <pre>
 *   'processed': Transaction landed in a block which has reached 1 confirmation by the connected node
 *   'confirmed': Transaction landed in a block which has reached 1 confirmation by the cluster
 *   'finalized': Transaction landed in a block which has been finalized by the cluster
 * </pre>
 */
declare type TransactionConfirmationStatus =
  | "processed"
  | "confirmed"
  | "finalized";
/**
 * Signature status
 */
declare type SignatureStatus = {
  /**
   * when the transaction was processed
   */
  slot: number,

  /**
   * the number of blocks that have been confirmed and voted on in the fork containing `slot`
   */
  confirmations: number | null,

  /**
   * transaction error, if any
   */
  err: TransactionError | null,

  /**
   * cluster confirmation status, if data available. Possible responses: `processed`, `confirmed`, `finalized`
   */
  confirmationStatus?: TransactionConfirmationStatus,
  ...
};
/**
 * A confirmed signature with its status
 * @typedef ConfirmedSignatureInfo
 */
declare type ConfirmedSignatureInfo = {
  signature: string,
  slot: number,
  err: TransactionError | null,
  memo: string | null,
  blockTime?: number | null,
  ...
};
/**
 * A connection to a fullnode JSON RPC endpoint
 */
declare class Connection {
  /**
   * @internal
   */
  _commitment?: Commitment;

  /**
   * @internal
   */
  _rpcEndpoint: string;

  /**
   * @internal
   */
  _rpcClient: RpcClient;

  /**
   * @internal
   */
  _rpcRequest: RpcRequest;

  /**
   * @internal
   */
  _rpcBatchRequest: RpcBatchRequest;

  /**
   * @internal
   */
  _rpcWebSocket: RpcWebSocketClient;

  /**
   * @internal
   */
  _rpcWebSocketConnected: boolean;

  /**
   * @internal
   */
  _rpcWebSocketHeartbeat: $Call<
    <R>((...args: any[]) => R) => R,
    typeof setInterval
  > | null;

  /**
   * @internal
   */
  _rpcWebSocketIdleTimeout: $Call<
    <R>((...args: any[]) => R) => R,
    typeof setTimeout
  > | null;

  /**
   * @internal
   */
  _disableBlockhashCaching: boolean;

  /**
   * @internal
   */
  _pollingBlockhash: boolean;

  /**
   * @internal
   */
  _blockhashInfo: {
    recentBlockhash: Blockhash | null,
    lastFetch: number,
    simulatedSignatures: Array<string>,
    transactionSignatures: Array<string>,
    ...
  };

  /**
   * @internal
   */
  _accountChangeSubscriptionCounter: number;

  /**
   * @internal
   */
  _accountChangeSubscriptions: {
    [id: number]: AccountSubscriptionInfo,
    ...
  };

  /**
   * @internal
   */
  _programAccountChangeSubscriptionCounter: number;

  /**
   * @internal
   */
  _programAccountChangeSubscriptions: {
    [id: number]: ProgramAccountSubscriptionInfo,
    ...
  };

  /**
   * @internal
   */
  _rootSubscriptionCounter: number;

  /**
   * @internal
   */
  _rootSubscriptions: {
    [id: number]: RootSubscriptionInfo,
    ...
  };

  /**
   * @internal
   */
  _signatureSubscriptionCounter: number;

  /**
   * @internal
   */
  _signatureSubscriptions: {
    [id: number]: SignatureSubscriptionInfo,
    ...
  };

  /**
   * @internal
   */
  _slotSubscriptionCounter: number;

  /**
   * @internal
   */
  _slotSubscriptions: {
    [id: number]: SlotSubscriptionInfo,
    ...
  };

  /**
   * @internal
   */
  _logsSubscriptionCounter: number;

  /**
   * @internal
   */
  _logsSubscriptions: {
    [id: number]: LogsSubscriptionInfo,
    ...
  };

  /**
   * Establish a JSON RPC connection
   * @param endpoint URL to the fullnode JSON RPC endpoint
   * @param commitment optional default commitment level
   */
  constructor(endpoint: string, commitment?: Commitment): this;

  /**
   * The default commitment used for requests
   */
  commitment: Commitment | void;

  /**
   * Fetch the balance for the specified public key, return with context
   */
  getBalanceAndContext(
    publicKey: PublicKey,
    commitment?: Commitment
  ): Promise<RpcResponseAndContext<number>>;

  /**
   * Fetch the balance for the specified public key
   */
  getBalance(publicKey: PublicKey, commitment?: Commitment): Promise<number>;

  /**
   * Fetch the estimated production time of a block
   */
  getBlockTime(slot: number): Promise<number | null>;

  /**
   * Fetch the lowest slot that the node has information about in its ledger.
   * This value may increase over time if the node is configured to purge older ledger data
   */
  getMinimumLedgerSlot(): Promise<number>;

  /**
   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
   */
  getFirstAvailableBlock(): Promise<number>;

  /**
   * Fetch information about the current supply
   */
  getSupply(commitment?: Commitment): Promise<RpcResponseAndContext<Supply>>;

  /**
   * Fetch the current supply of a token mint
   */
  getTokenSupply(
    tokenMintAddress: PublicKey,
    commitment?: Commitment
  ): Promise<RpcResponseAndContext<TokenAmount>>;

  /**
   * Fetch the current balance of a token account
   */
  getTokenAccountBalance(
    tokenAddress: PublicKey,
    commitment?: Commitment
  ): Promise<RpcResponseAndContext<TokenAmount>>;

  /**
 * Fetch all the token accounts owned by the specified account
 * @return {Promise<RpcResponseAndContext<Array<{
pubkey: PublicKey,
account: AccountInfo<Buffer>,...
}>>>}
 */
  getTokenAccountsByOwner(
    ownerAddress: PublicKey,
    filter: TokenAccountsFilter,
    commitment?: Commitment
  ): Promise<
    RpcResponseAndContext<
      Array<{
        pubkey: PublicKey,
        account: AccountInfo<Buffer>,
        ...
      }>
    >
  >;

  /**
 * Fetch parsed token accounts owned by the specified account
 * @return {Promise<RpcResponseAndContext<Array<{
pubkey: PublicKey,
account: AccountInfo<ParsedAccountData>,...
}>>>}
 */
  getParsedTokenAccountsByOwner(
    ownerAddress: PublicKey,
    filter: TokenAccountsFilter,
    commitment?: Commitment
  ): Promise<
    RpcResponseAndContext<
      Array<{
        pubkey: PublicKey,
        account: AccountInfo<ParsedAccountData>,
        ...
      }>
    >
  >;

  /**
   * Fetch the 20 largest accounts with their current balances
   */
  getLargestAccounts(
    config?: GetLargestAccountsConfig
  ): Promise<RpcResponseAndContext<Array<AccountBalancePair>>>;

  /**
   * Fetch the 20 largest token accounts with their current balances
   * for a given mint.
   */
  getTokenLargestAccounts(
    mintAddress: PublicKey,
    commitment?: Commitment
  ): Promise<RpcResponseAndContext<Array<TokenAccountBalancePair>>>;

  /**
   * Fetch all the account info for the specified public key, return with context
   */
  getAccountInfoAndContext(
    publicKey: PublicKey,
    commitment?: Commitment
  ): Promise<RpcResponseAndContext<AccountInfo<Buffer> | null>>;

  /**
   * Fetch parsed account info for the specified public key
   */
  getParsedAccountInfo(
    publicKey: PublicKey,
    commitment?: Commitment
  ): Promise<
    RpcResponseAndContext<AccountInfo<Buffer | ParsedAccountData> | null>
  >;

  /**
   * Fetch all the account info for the specified public key
   */
  getAccountInfo(
    publicKey: PublicKey,
    commitment?: Commitment
  ): Promise<AccountInfo<Buffer> | null>;

  /**
   * Returns epoch activation information for a stake account that has been delegated
   */
  getStakeActivation(
    publicKey: PublicKey,
    commitment?: Commitment,
    epoch?: number
  ): Promise<StakeActivationData>;

  /**
 * Fetch all the accounts owned by the specified program id
 * @return {Promise<Array<{
pubkey: PublicKey,
account: AccountInfo<Buffer>,...
}>>}
 */
  getProgramAccounts(
    programId: PublicKey,
    commitment?: Commitment
  ): Promise<
    Array<{
      pubkey: PublicKey,
      account: AccountInfo<Buffer>,
      ...
    }>
  >;

  /**
 * Fetch and parse all the accounts owned by the specified program id
 * @return {Promise<Array<{
pubkey: PublicKey,
account: AccountInfo<Buffer | ParsedAccountData>,...
}>>}
 */
  getParsedProgramAccounts(
    programId: PublicKey,
    commitment?: Commitment
  ): Promise<
    Array<{
      pubkey: PublicKey,
      account: AccountInfo<Buffer | ParsedAccountData>,
      ...
    }>
  >;

  /**
   * Confirm the transaction identified by the specified signature.
   */
  confirmTransaction(
    signature: TransactionSignature,
    commitment?: Commitment
  ): Promise<RpcResponseAndContext<SignatureResult>>;

  /**
   * Return the list of nodes that are currently participating in the cluster
   */
  getClusterNodes(): Promise<Array<ContactInfo>>;

  /**
   * Return the list of nodes that are currently participating in the cluster
   */
  getVoteAccounts(commitment?: Commitment): Promise<VoteAccountStatus>;

  /**
   * Fetch the current slot that the node is processing
   */
  getSlot(commitment?: Commitment): Promise<number>;

  /**
   * Fetch the current slot leader of the cluster
   */
  getSlotLeader(commitment?: Commitment): Promise<string>;

  /**
   * Fetch the current status of a signature
   */
  getSignatureStatus(
    signature: TransactionSignature,
    config?: SignatureStatusConfig
  ): Promise<RpcResponseAndContext<SignatureStatus | null>>;

  /**
   * Fetch the current statuses of a batch of signatures
   */
  getSignatureStatuses(
    signatures: Array<TransactionSignature>,
    config?: SignatureStatusConfig
  ): Promise<RpcResponseAndContext<Array<SignatureStatus | null>>>;

  /**
   * Fetch the current transaction count of the cluster
   */
  getTransactionCount(commitment?: Commitment): Promise<number>;

  /**
   * Fetch the current total currency supply of the cluster in lamports
   */
  getTotalSupply(commitment?: Commitment): Promise<number>;

  /**
   * Fetch the cluster InflationGovernor parameters
   */
  getInflationGovernor(commitment?: Commitment): Promise<InflationGovernor>;

  /**
   * Fetch the Epoch Info parameters
   */
  getEpochInfo(commitment?: Commitment): Promise<EpochInfo>;

  /**
   * Fetch the Epoch Schedule parameters
   */
  getEpochSchedule(): Promise<EpochSchedule>;

  /**
   * Fetch the leader schedule for the current epoch
   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
   */
  getLeaderSchedule(): Promise<LeaderSchedule>;

  /**
   * Fetch the minimum balance needed to exempt an account of `dataLength`
   * size from rent
   */
  getMinimumBalanceForRentExemption(
    dataLength: number,
    commitment?: Commitment
  ): Promise<number>;

  /**
 * Fetch a recent blockhash from the cluster, return with context
 * @return {Promise<RpcResponseAndContext<{
blockhash: Blockhash,
feeCalculator: FeeCalculator,...
}>>}
 */
  getRecentBlockhashAndContext(
    commitment?: Commitment
  ): Promise<
    RpcResponseAndContext<{
      blockhash: Blockhash,
      feeCalculator: FeeCalculator,
      ...
    }>
  >;

  /**
   * Fetch recent performance samples
   * @return {Promise<Array<PerfSample>>}
   */
  getRecentPerformanceSamples(limit?: number): Promise<Array<PerfSample>>;

  /**
   * Fetch the fee calculator for a recent blockhash from the cluster, return with context
   */
  getFeeCalculatorForBlockhash(
    blockhash: Blockhash,
    commitment?: Commitment
  ): Promise<RpcResponseAndContext<FeeCalculator | null>>;

  /**
 * Fetch a recent blockhash from the cluster
 * @return {Promise<{
blockhash: Blockhash,
feeCalculator: FeeCalculator,...
}>}
 */
  getRecentBlockhash(
    commitment?: Commitment
  ): Promise<{
    blockhash: Blockhash,
    feeCalculator: FeeCalculator,
    ...
  }>;

  /**
   * Fetch the node version
   */
  getVersion(): Promise<Version>;

  /**
   * Fetch a list of Transactions and transaction statuses from the cluster
   * for a confirmed block
   */
  getConfirmedBlock(slot: number): Promise<ConfirmedBlock>;

  /**
   * Fetch a transaction details for a confirmed transaction
   */
  getConfirmedTransaction(
    signature: TransactionSignature
  ): Promise<ConfirmedTransaction | null>;

  /**
   * Fetch parsed transaction details for a confirmed transaction
   */
  getParsedConfirmedTransaction(
    signature: TransactionSignature
  ): Promise<ParsedConfirmedTransaction | null>;

  /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   */
  getParsedConfirmedTransactions(
    signatures: TransactionSignature[]
  ): Promise<(ParsedConfirmedTransaction | null)[]>;

  /**
   * Fetch a list of all the confirmed signatures for transactions involving an address
   * within a specified slot range. Max range allowed is 10,000 slots.
   * @param address queried address
   * @param startSlot start slot, inclusive
   * @param endSlot end slot, inclusive
   */
  getConfirmedSignaturesForAddress(
    address: PublicKey,
    startSlot: number,
    endSlot: number
  ): Promise<Array<TransactionSignature>>;

  /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   * @param address queried address
   * @param options
   */
  getConfirmedSignaturesForAddress2(
    address: PublicKey,
    options?: ConfirmedSignaturesForAddress2Options
  ): Promise<Array<ConfirmedSignatureInfo>>;

  /**
   * Fetch the contents of a Nonce account from the cluster, return with context
   */
  getNonceAndContext(
    nonceAccount: PublicKey,
    commitment?: Commitment
  ): Promise<RpcResponseAndContext<NonceAccount | null>>;

  /**
   * Fetch the contents of a Nonce account from the cluster
   */
  getNonce(
    nonceAccount: PublicKey,
    commitment?: Commitment
  ): Promise<NonceAccount | null>;

  /**
   * Request an allocation of lamports to the specified account
   */
  requestAirdrop(to: PublicKey, amount: number): Promise<TransactionSignature>;

  /**
   * @internal
   */
  _recentBlockhash(disableCache: boolean): Promise<Blockhash>;

  /**
   * @internal
   */
  _pollNewBlockhash(): Promise<Blockhash>;

  /**
   * Simulate a transaction
   */
  simulateTransaction(
    transaction: Transaction,
    signers?: Array<Account>
  ): Promise<RpcResponseAndContext<SimulatedTransactionResponse>>;

  /**
   * Sign and send a transaction
   */
  sendTransaction(
    transaction: Transaction,
    signers: Array<Account>,
    options?: SendOptions
  ): Promise<TransactionSignature>;

  /**
   * Send a transaction that has already been signed and serialized into the
   * wire format
   */
  sendRawTransaction(
    rawTransaction: Buffer | Uint8Array | Array<number>,
    options?: SendOptions
  ): Promise<TransactionSignature>;

  /**
   * Send a transaction that has already been signed, serialized into the
   * wire format, and encoded as a base64 string
   */
  sendEncodedTransaction(
    encodedTransaction: string,
    options?: SendOptions
  ): Promise<TransactionSignature>;

  /**
   * @internal
   */
  _wsOnOpen(): void;

  /**
   * @internal
   */
  _wsOnError(err: Error): void;

  /**
   * @internal
   */
  _wsOnClose(code: number): void;

  /**
   * @internal
   */
  _subscribe(
    sub: {
      subscriptionId: SubscriptionId | null,
      ...
    },
    rpcMethod: string,
    rpcArgs: IWSRequestParams
  ): Promise<void>;

  /**
   * @internal
   */
  _unsubscribe(
    sub: {
      subscriptionId: SubscriptionId | null,
      ...
    },
    rpcMethod: string
  ): Promise<void>;

  /**
   * @internal
   */
  _resetSubscriptions(): void;

  /**
   * @internal
   */
  _updateSubscriptions(): void;

  /**
   * @internal
   */
  _wsOnAccountNotification(notification: { [key: string]: any }): void;

  /**
   * Register a callback to be invoked whenever the specified account changes
   * @param publicKey Public key of the account to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param commitment Specify the commitment level account changes must reach before notification
   * @return subscription id
   */
  onAccountChange(
    publicKey: PublicKey,
    callback: AccountChangeCallback,
    commitment?: Commitment
  ): number;

  /**
   * Deregister an account notification callback
   * @param id subscription id to deregister
   */
  removeAccountChangeListener(id: number): Promise<void>;

  /**
   * @internal
   */
  _wsOnProgramAccountNotification(notification: Object): void;

  /**
   * Register a callback to be invoked whenever accounts owned by the
   * specified program change
   * @param programId Public key of the program to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param commitment Specify the commitment level account changes must reach before notification
   * @return subscription id
   */
  onProgramAccountChange(
    programId: PublicKey,
    callback: ProgramAccountChangeCallback,
    commitment?: Commitment
  ): number;

  /**
   * Deregister an account notification callback
   * @param id subscription id to deregister
   */
  removeProgramAccountChangeListener(id: number): Promise<void>;

  /**
   * Registers a callback to be invoked whenever logs are emitted.
   */
  onLogs(
    filter: LogsFilter,
    callback: LogsCallback,
    commitment?: Commitment
  ): number;

  /**
   * Deregister a logs callback.
   * @param id subscription id to deregister.
   */
  removeOnLogsListener(id: number): Promise<void>;

  /**
   * @internal
   */
  _wsOnLogsNotification(notification: Object): void;

  /**
   * @internal
   */
  _wsOnSlotNotification(notification: Object): void;

  /**
   * Register a callback to be invoked upon slot changes
   * @param callback Function to invoke whenever the slot changes
   * @return subscription id
   */
  onSlotChange(callback: SlotChangeCallback): number;

  /**
   * Deregister a slot notification callback
   * @param id subscription id to deregister
   */
  removeSlotChangeListener(id: number): Promise<void>;

  /**
   * @internal
   */
  _buildArgs(
    args: Array<any>,
    override?: Commitment,
    encoding?: "jsonParsed" | "base64",
    extra?: any
  ): Array<any>;

  /**
   * @internal
   */
  _wsOnSignatureNotification(notification: Object): void;

  /**
   * Register a callback to be invoked upon signature updates
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param commitment Specify the commitment level signature must reach before notification
   * @return subscription id
   */
  onSignature(
    signature: TransactionSignature,
    callback: SignatureResultCallback,
    commitment?: Commitment
  ): number;

  /**
   * Register a callback to be invoked when a transaction is
   * received and/or processed.
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param options Enable received notifications and set the commitment
   * level that signature must reach before notification
   * @return subscription id
   */
  onSignatureWithOptions(
    signature: TransactionSignature,
    callback: SignatureSubscriptionCallback,
    options?: SignatureSubscriptionOptions
  ): number;

  /**
   * Deregister a signature notification callback
   * @param id subscription id to deregister
   */
  removeSignatureListener(id: number): Promise<void>;

  /**
   * @internal
   */
  _wsOnRootNotification(notification: Object): void;

  /**
   * Register a callback to be invoked upon root changes
   * @param callback Function to invoke whenever the root changes
   * @return subscription id
   */
  onRootChange(callback: RootChangeCallback): number;

  /**
   * Deregister a root notification callback
   * @param id subscription id to deregister
   */
  removeRootChangeListener(id: number): Promise<void>;
}
declare var BPF_LOADER_PROGRAM_ID: PublicKey;
/**
 * Factory class for transactions to interact with a program loader
 */
declare class BpfLoader {
  /**
   * Minimum number of signatures required to load a program not including
   * retries
   *
   * Can be used to calculate transaction fees
   */
  static getMinNumSignatures(dataLength: number): number;

  /**
   * Load a BPF program
   * @param connection The connection to use
   * @param payer Account that will pay program loading fees
   * @param program Account to load the program into
   * @param elf The entire ELF containing the BPF program
   * @param loaderProgramId The program id of the BPF loader to use
   * @return true if program was loaded successfully, false if program was already loaded
   */
  static load(
    connection: Connection,
    payer: Account,
    program: Account,
    elf: Buffer | Uint8Array | Array<number>,
    loaderProgramId: PublicKey
  ): Promise<boolean>;
}
/**
 * Program loader interface
 */
declare class Loader {
  /**
   * @internal
   */
  constructor(): this;

  /**
   * Amount of program data placed in each load Transaction
   */
  chunkSize: number;

  /**
   * Minimum number of signatures required to load a program not including
   * retries
   *
   * Can be used to calculate transaction fees
   */
  static getMinNumSignatures(dataLength: number): number;

  /**
   * Loads a generic program
   * @param connection The connection to use
   * @param payer System account that pays to load the program
   * @param program Account to load the program into
   * @param programId Public key that identifies the loader
   * @param data Program octets
   * @return true if program was loaded successfully, false if program was already loaded
   */
  static load(
    connection: Connection,
    payer: Account,
    program: Account,
    programId: PublicKey,
    data: Buffer | Uint8Array | Array<number>
  ): Promise<boolean>;
}
/**
 * @typedef InstructionType
 * @internal
 */
declare type InstructionType = {
  index: number,
  layout: typeof BufferLayout,
  ...
};
/**
 * Address of the stake config account which configures the rate
 * of stake warmup and cooldown as well as the slashing penalty.
 */
declare var STAKE_CONFIG_ID: PublicKey;
/**
 * Stake account authority info
 */
declare class Authorized {
  /**
   * stake authority
   */
  staker: PublicKey;

  /**
   * withdraw authority
   */
  withdrawer: PublicKey;

  /**
   * Create a new Authorized object
   * @param staker the stake authority
   * @param withdrawer the withdraw authority
   */
  constructor(staker: PublicKey, withdrawer: PublicKey): this;
}
/**
 * Stake account lockup info
 */
declare class Lockup {
  /**
   * Unix timestamp of lockup expiration
   */
  unixTimestamp: number;

  /**
   * Epoch of lockup expiration
   */
  epoch: number;

  /**
   * Lockup custodian authority
   */
  custodian: PublicKey;

  /**
   * Create a new Lockup object
   */
  constructor(unixTimestamp: number, epoch: number, custodian: PublicKey): this;
}
/**
 * Create stake account transaction params
 */
declare type CreateStakeAccountParams = {
  /**
   * Address of the account which will fund creation
   */
  fromPubkey: PublicKey,

  /**
   * Address of the new stake account
   */
  stakePubkey: PublicKey,

  /**
   * Authorities of the new stake account
   */
  authorized: Authorized,

  /**
   * Lockup of the new stake account
   */
  lockup: Lockup,

  /**
   * Funding amount
   */
  lamports: number,
  ...
};
/**
 * Create stake account with seed transaction params
 */
declare type CreateStakeAccountWithSeedParams = {
  fromPubkey: PublicKey,
  stakePubkey: PublicKey,
  basePubkey: PublicKey,
  seed: string,
  authorized: Authorized,
  lockup: Lockup,
  lamports: number,
  ...
};
/**
 * Initialize stake instruction params
 */
declare type InitializeStakeParams = {
  stakePubkey: PublicKey,
  authorized: Authorized,
  lockup: Lockup,
  ...
};
/**
 * Delegate stake instruction params
 */
declare type DelegateStakeParams = {
  stakePubkey: PublicKey,
  authorizedPubkey: PublicKey,
  votePubkey: PublicKey,
  ...
};
/**
 * Authorize stake instruction params
 */
declare type AuthorizeStakeParams = {
  stakePubkey: PublicKey,
  authorizedPubkey: PublicKey,
  newAuthorizedPubkey: PublicKey,
  stakeAuthorizationType: StakeAuthorizationType,
  custodianPubkey?: PublicKey,
  ...
};
/**
 * Authorize stake instruction params using a derived key
 */
declare type AuthorizeWithSeedStakeParams = {
  stakePubkey: PublicKey,
  authorityBase: PublicKey,
  authoritySeed: string,
  authorityOwner: PublicKey,
  newAuthorizedPubkey: PublicKey,
  stakeAuthorizationType: StakeAuthorizationType,
  custodianPubkey?: PublicKey,
  ...
};
/**
 * Split stake instruction params
 */
declare type SplitStakeParams = {
  stakePubkey: PublicKey,
  authorizedPubkey: PublicKey,
  splitStakePubkey: PublicKey,
  lamports: number,
  ...
};
/**
 * Withdraw stake instruction params
 */
declare type WithdrawStakeParams = {
  stakePubkey: PublicKey,
  authorizedPubkey: PublicKey,
  toPubkey: PublicKey,
  lamports: number,
  custodianPubkey?: PublicKey,
  ...
};
/**
 * Deactivate stake instruction params
 */
declare type DeactivateStakeParams = {
  stakePubkey: PublicKey,
  authorizedPubkey: PublicKey,
  ...
};
/**
 * Stake Instruction class
 */
declare class StakeInstruction {
  /**
   * @internal
   */
  constructor(): this;

  /**
   * Decode a stake instruction and retrieve the instruction type.
   */
  static decodeInstructionType(
    instruction: TransactionInstruction
  ): StakeInstructionType;

  /**
   * Decode a initialize stake instruction and retrieve the instruction params.
   */
  static decodeInitialize(
    instruction: TransactionInstruction
  ): InitializeStakeParams;

  /**
   * Decode a delegate stake instruction and retrieve the instruction params.
   */
  static decodeDelegate(
    instruction: TransactionInstruction
  ): DelegateStakeParams;

  /**
   * Decode an authorize stake instruction and retrieve the instruction params.
   */
  static decodeAuthorize(
    instruction: TransactionInstruction
  ): AuthorizeStakeParams;

  /**
   * Decode an authorize-with-seed stake instruction and retrieve the instruction params.
   */
  static decodeAuthorizeWithSeed(
    instruction: TransactionInstruction
  ): AuthorizeWithSeedStakeParams;

  /**
   * Decode a split stake instruction and retrieve the instruction params.
   */
  static decodeSplit(instruction: TransactionInstruction): SplitStakeParams;

  /**
   * Decode a withdraw stake instruction and retrieve the instruction params.
   */
  static decodeWithdraw(
    instruction: TransactionInstruction
  ): WithdrawStakeParams;

  /**
   * Decode a deactivate stake instruction and retrieve the instruction params.
   */
  static decodeDeactivate(
    instruction: TransactionInstruction
  ): DeactivateStakeParams;

  /**
   * @internal
   */
  static checkProgramId(programId: PublicKey): void;

  /**
   * @internal
   */
  static checkKeyLength(keys: Array<any>, expectedLength: number): void;
}
/**
 * An enumeration of valid StakeInstructionType's
 */
declare type StakeInstructionType =
  | "AuthorizeWithSeed"
  | "Authorize"
  | "Deactivate"
  | "Delegate"
  | "Initialize"
  | "Split"
  | "Withdraw";
/**
 * An enumeration of valid stake InstructionType's
 */
declare var STAKE_INSTRUCTION_LAYOUTS: $ObjMapi<
  { [k: StakeInstructionType]: any },
  <type>(type) => InstructionType
>;
/**
 * @typedef StakeAuthorizationType
 */
declare type StakeAuthorizationType = {
  index: number,
  ...
};
/**
 * An enumeration of valid StakeAuthorizationLayout's
 */
declare var StakeAuthorizationLayout: $ReadOnly<{
  Staker: {
    index: number,
    ...
  },
  Withdrawer: {
    index: number,
    ...
  },
  ...
}>;
/**
 * Factory class for transactions to interact with the Stake program
 */
declare class StakeProgram {
  /**
   * @internal
   */
  constructor(): this;

  /**
   * Public key that identifies the Stake program
   */
  programId: PublicKey;

  /**
   * Max space of a Stake account
   *
   * This is generated from the solana-stake-program StakeState struct as
   * `std::mem::size_of::<StakeState>()`:
   * https://docs.rs/solana-stake-program/1.4.4/solana_stake_program/stake_state/enum.StakeState.html
   */
  space: number;

  /**
   * Generate an Initialize instruction to add to a Stake Create transaction
   */
  static initialize(params: InitializeStakeParams): TransactionInstruction;

  /**
   * Generate a Transaction that creates a new Stake account at
   *   an address generated with `from`, a seed, and the Stake programId
   */
  static createAccountWithSeed(
    params: CreateStakeAccountWithSeedParams
  ): Transaction;

  /**
   * Generate a Transaction that creates a new Stake account
   */
  static createAccount(params: CreateStakeAccountParams): Transaction;

  /**
   * Generate a Transaction that delegates Stake tokens to a validator
   * Vote PublicKey. This transaction can also be used to redelegate Stake
   * to a new validator Vote PublicKey.
   */
  static delegate(params: DelegateStakeParams): Transaction;

  /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */
  static authorize(params: AuthorizeStakeParams): Transaction;

  /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */
  static authorizeWithSeed(params: AuthorizeWithSeedStakeParams): Transaction;

  /**
   * Generate a Transaction that splits Stake tokens into another stake account
   */
  static split(params: SplitStakeParams): Transaction;

  /**
   * Generate a Transaction that withdraws deactivated Stake tokens.
   */
  static withdraw(params: WithdrawStakeParams): Transaction;

  /**
   * Generate a Transaction that deactivates Stake tokens.
   */
  static deactivate(params: DeactivateStakeParams): Transaction;
}
/**
 * Create account system transaction params
 * @typedef CreateAccountParams
 */
declare type CreateAccountParams = {
  fromPubkey: PublicKey,
  newAccountPubkey: PublicKey,
  lamports: number,
  space: number,
  programId: PublicKey,
  ...
};
/**
 * Transfer system transaction params
 * @typedef TransferParams
 */
declare type TransferParams = {
  fromPubkey: PublicKey,
  toPubkey: PublicKey,
  lamports: number,
  ...
};
/**
 * Assign system transaction params
 * @typedef AssignParams
 */
declare type AssignParams = {
  accountPubkey: PublicKey,
  programId: PublicKey,
  ...
};
/**
 * Create account with seed system transaction params
 * @typedef CreateAccountWithSeedParams
 */
declare type CreateAccountWithSeedParams = {
  fromPubkey: PublicKey,
  newAccountPubkey: PublicKey,
  basePubkey: PublicKey,
  seed: string,
  lamports: number,
  space: number,
  programId: PublicKey,
  ...
};
/**
 * Create nonce account system transaction params
 * @typedef CreateNonceAccountParams
 */
declare type CreateNonceAccountParams = {
  fromPubkey: PublicKey,
  noncePubkey: PublicKey,
  authorizedPubkey: PublicKey,
  lamports: number,
  ...
};
/**
 * Create nonce account with seed system transaction params
 * @typedef CreateNonceAccountWithSeedParams
 */
declare type CreateNonceAccountWithSeedParams = {
  fromPubkey: PublicKey,
  noncePubkey: PublicKey,
  authorizedPubkey: PublicKey,
  lamports: number,
  basePubkey: PublicKey,
  seed: string,
  ...
};
/**
 * Initialize nonce account system instruction params
 * @typedef InitializeNonceParams
 */
declare type InitializeNonceParams = {
  noncePubkey: PublicKey,
  authorizedPubkey: PublicKey,
  ...
};
/**
 * Advance nonce account system instruction params
 * @typedef AdvanceNonceParams
 */
declare type AdvanceNonceParams = {
  noncePubkey: PublicKey,
  authorizedPubkey: PublicKey,
  ...
};
/**
 * Withdraw nonce account system transaction params
 * @typedef WithdrawNonceParams
 */
declare type WithdrawNonceParams = {
  noncePubkey: PublicKey,
  authorizedPubkey: PublicKey,
  toPubkey: PublicKey,
  lamports: number,
  ...
};
/**
 * Authorize nonce account system transaction params
 * @typedef AuthorizeNonceParams
 */
declare type AuthorizeNonceParams = {
  noncePubkey: PublicKey,
  authorizedPubkey: PublicKey,
  newAuthorizedPubkey: PublicKey,
  ...
};
/**
 * Allocate account system transaction params
 * @typedef AllocateParams
 */
declare type AllocateParams = {
  accountPubkey: PublicKey,
  space: number,
  ...
};
/**
 * Allocate account with seed system transaction params
 * @typedef AllocateWithSeedParams
 */
declare type AllocateWithSeedParams = {
  accountPubkey: PublicKey,
  basePubkey: PublicKey,
  seed: string,
  space: number,
  programId: PublicKey,
  ...
};
/**
 * Assign account with seed system transaction params
 * @typedef AssignWithSeedParams
 */
declare type AssignWithSeedParams = {
  accountPubkey: PublicKey,
  basePubkey: PublicKey,
  seed: string,
  programId: PublicKey,
  ...
};
/**
 * Transfer with seed system transaction params
 * @typedef TransferWithSeedParams
 */
declare type TransferWithSeedParams = {
  fromPubkey: PublicKey,
  basePubkey: PublicKey,
  toPubkey: PublicKey,
  lamports: number,
  seed: string,
  programId: PublicKey,
  ...
};
/**
 * System Instruction class
 */
declare class SystemInstruction {
  /**
   * @internal
   */
  constructor(): this;

  /**
   * Decode a system instruction and retrieve the instruction type.
   */
  static decodeInstructionType(
    instruction: TransactionInstruction
  ): SystemInstructionType;

  /**
   * Decode a create account system instruction and retrieve the instruction params.
   */
  static decodeCreateAccount(
    instruction: TransactionInstruction
  ): CreateAccountParams;

  /**
   * Decode a transfer system instruction and retrieve the instruction params.
   */
  static decodeTransfer(instruction: TransactionInstruction): TransferParams;

  /**
   * Decode a transfer with seed system instruction and retrieve the instruction params.
   */
  static decodeTransferWithSeed(
    instruction: TransactionInstruction
  ): TransferWithSeedParams;

  /**
   * Decode an allocate system instruction and retrieve the instruction params.
   */
  static decodeAllocate(instruction: TransactionInstruction): AllocateParams;

  /**
   * Decode an allocate with seed system instruction and retrieve the instruction params.
   */
  static decodeAllocateWithSeed(
    instruction: TransactionInstruction
  ): AllocateWithSeedParams;

  /**
   * Decode an assign system instruction and retrieve the instruction params.
   */
  static decodeAssign(instruction: TransactionInstruction): AssignParams;

  /**
   * Decode an assign with seed system instruction and retrieve the instruction params.
   */
  static decodeAssignWithSeed(
    instruction: TransactionInstruction
  ): AssignWithSeedParams;

  /**
   * Decode a create account with seed system instruction and retrieve the instruction params.
   */
  static decodeCreateWithSeed(
    instruction: TransactionInstruction
  ): CreateAccountWithSeedParams;

  /**
   * Decode a nonce initialize system instruction and retrieve the instruction params.
   */
  static decodeNonceInitialize(
    instruction: TransactionInstruction
  ): InitializeNonceParams;

  /**
   * Decode a nonce advance system instruction and retrieve the instruction params.
   */
  static decodeNonceAdvance(
    instruction: TransactionInstruction
  ): AdvanceNonceParams;

  /**
   * Decode a nonce withdraw system instruction and retrieve the instruction params.
   */
  static decodeNonceWithdraw(
    instruction: TransactionInstruction
  ): WithdrawNonceParams;

  /**
   * Decode a nonce authorize system instruction and retrieve the instruction params.
   */
  static decodeNonceAuthorize(
    instruction: TransactionInstruction
  ): AuthorizeNonceParams;

  /**
   * @internal
   */
  static checkProgramId(programId: PublicKey): void;

  /**
   * @internal
   */
  static checkKeyLength(keys: Array<any>, expectedLength: number): void;
}
/**
 * An enumeration of valid SystemInstructionType's
 */
declare type SystemInstructionType =
  | "AdvanceNonceAccount"
  | "Allocate"
  | "AllocateWithSeed"
  | "Assign"
  | "AssignWithSeed"
  | "AuthorizeNonceAccount"
  | "Create"
  | "CreateWithSeed"
  | "InitializeNonceAccount"
  | "Transfer"
  | "TransferWithSeed"
  | "WithdrawNonceAccount";
/**
 * An enumeration of valid system InstructionType's
 */
declare var SYSTEM_INSTRUCTION_LAYOUTS: $ObjMapi<
  { [k: SystemInstructionType]: any },
  <type>(type) => InstructionType
>;
/**
 * Factory class for transactions to interact with the System program
 */
declare class SystemProgram {
  /**
   * @internal
   */
  constructor(): this;

  /**
   * Public key that identifies the System program
   */
  programId: PublicKey;

  /**
   * Generate a transaction instruction that creates a new account
   */
  static createAccount(params: CreateAccountParams): TransactionInstruction;

  /**
   * Generate a transaction instruction that transfers lamports from one account to another
   */
  static transfer(
    params: TransferParams | TransferWithSeedParams
  ): TransactionInstruction;

  /**
   * Generate a transaction instruction that assigns an account to a program
   */
  static assign(
    params: AssignParams | AssignWithSeedParams
  ): TransactionInstruction;

  /**
   * Generate a transaction instruction that creates a new account at
   *   an address generated with `from`, a seed, and programId
   */
  static createAccountWithSeed(
    params: CreateAccountWithSeedParams
  ): TransactionInstruction;

  /**
   * Generate a transaction that creates a new Nonce account
   */
  static createNonceAccount(
    params: CreateNonceAccountParams | CreateNonceAccountWithSeedParams
  ): Transaction;

  /**
   * Generate an instruction to initialize a Nonce account
   */
  static nonceInitialize(params: InitializeNonceParams): TransactionInstruction;

  /**
   * Generate an instruction to advance the nonce in a Nonce account
   */
  static nonceAdvance(params: AdvanceNonceParams): TransactionInstruction;

  /**
   * Generate a transaction instruction that withdraws lamports from a Nonce account
   */
  static nonceWithdraw(params: WithdrawNonceParams): TransactionInstruction;

  /**
   * Generate a transaction instruction that authorizes a new PublicKey as the authority
   * on a Nonce account.
   */
  static nonceAuthorize(params: AuthorizeNonceParams): TransactionInstruction;

  /**
   * Generate a transaction instruction that allocates space in an account without funding
   */
  static allocate(
    params: AllocateParams | AllocateWithSeedParams
  ): TransactionInstruction;
}
/**
 * Params for creating an secp256k1 instruction using a public key
 * @typedef CreateSecp256k1InstructionWithPublicKeyParams
 */
declare type CreateSecp256k1InstructionWithPublicKeyParams = {
  publicKey: Buffer | Uint8Array | Array<number>,
  message: Buffer | Uint8Array | Array<number>,
  signature: Buffer | Uint8Array | Array<number>,
  recoveryId: number,
  ...
};
/**
 * Params for creating an secp256k1 instruction using an Ethereum address
 * @typedef CreateSecp256k1InstructionWithEthAddressParams
 */
declare type CreateSecp256k1InstructionWithEthAddressParams = {
  ethAddress: Buffer | Uint8Array | Array<number> | string,
  message: Buffer | Uint8Array | Array<number>,
  signature: Buffer | Uint8Array | Array<number>,
  recoveryId: number,
  ...
};
/**
 * Params for creating an secp256k1 instruction using a private key
 * @typedef CreateSecp256k1InstructionWithPrivateKeyParams
 */
declare type CreateSecp256k1InstructionWithPrivateKeyParams = {
  privateKey: Buffer | Uint8Array | Array<number>,
  message: Buffer | Uint8Array | Array<number>,
  ...
};
declare class Secp256k1Program {
  /**
   * @internal
   */
  constructor(): this;

  /**
   * Public key that identifies the secp256k1 program
   */
  programId: PublicKey;

  /**
   * Construct an Ethereum address from a secp256k1 public key buffer.
   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
   */
  static publicKeyToEthAddress(
    publicKey: Buffer | Uint8Array | Array<number>
  ): Buffer;

  /**
   * Create an secp256k1 instruction with a public key. The public key
   * must be a buffer that is 64 bytes long.
   */
  static createInstructionWithPublicKey(
    params: CreateSecp256k1InstructionWithPublicKeyParams
  ): TransactionInstruction;

  /**
   * Create an secp256k1 instruction with an Ethereum address. The address
   * must be a hex string or a buffer that is 20 bytes long.
   */
  static createInstructionWithEthAddress(
    params: CreateSecp256k1InstructionWithEthAddressParams
  ): TransactionInstruction;

  /**
   * Create an secp256k1 instruction with a private key. The private key
   * must be a buffer that is 32 bytes long.
   */
  static createInstructionWithPrivateKey(
    params: CreateSecp256k1InstructionWithPrivateKeyParams
  ): TransactionInstruction;
}
declare var VALIDATOR_INFO_KEY: PublicKey;
/**
 * Info used to identity validators.
 * @typedef Info
 */
declare type Info = {
  name: string,
  website?: string,
  details?: string,
  keybaseUsername?: string,
  ...
};
/**
 * ValidatorInfo class
 */
declare class ValidatorInfo {
  /**
   * validator public key
   */
  key: PublicKey;

  /**
   * validator information
   */
  info: Info;

  /**
   * Construct a valid ValidatorInfo
   * @param key validator public key
   * @param info validator information
   */
  constructor(key: PublicKey, info: Info): this;

  /**
   * Deserialize ValidatorInfo from the config account data. Exactly two config
   * keys are required in the data.
   * @param buffer config account data
   * @return null if info was not found
   */
  static fromConfigData(
    buffer: Buffer | Uint8Array | Array<number>
  ): ValidatorInfo | null;
}
declare var VOTE_PROGRAM_ID: PublicKey;
declare type Lockout = {
  slot: number,
  confirmationCount: number,
  ...
};
/**
 * History of how many credits earned by the end of each epoch
 */
declare type EpochCredits = {
  epoch: number,
  credits: number,
  prevCredits: number,
  ...
};
declare type VoteAccountArgs = {
  nodePubkey: PublicKey,
  authorizedVoterPubkey: PublicKey,
  authorizedWithdrawerPubkey: PublicKey,
  commission: number,
  votes: Array<Lockout>,
  rootSlot: number | null,
  epoch: number,
  credits: number,
  lastEpochCredits: number,
  epochCredits: Array<EpochCredits>,
  ...
};
/**
 * VoteAccount class
 */
declare class VoteAccount {
  nodePubkey: PublicKey;
  authorizedVoterPubkey: PublicKey;
  authorizedWithdrawerPubkey: PublicKey;
  commission: number;
  votes: Array<Lockout>;
  rootSlot: number | null;
  epoch: number;
  credits: number;
  lastEpochCredits: number;
  epochCredits: Array<EpochCredits>;

  /**
   * @internal
   */
  constructor(args: VoteAccountArgs): this;

  /**
   * Deserialize VoteAccount from the account data.
   * @param buffer account data
   * @return VoteAccount
   */
  static fromAccountData(
    buffer: Buffer | Uint8Array | Array<number>
  ): VoteAccount;
}
declare var SYSVAR_CLOCK_PUBKEY: PublicKey;
declare var SYSVAR_RECENT_BLOCKHASHES_PUBKEY: PublicKey;
declare var SYSVAR_RENT_PUBKEY: PublicKey;
declare var SYSVAR_REWARDS_PUBKEY: PublicKey;
declare var SYSVAR_STAKE_HISTORY_PUBKEY: PublicKey;
declare var SYSVAR_INSTRUCTIONS_PUBKEY: PublicKey;
/**
 * Sign, send and confirm a transaction.
 *
 * If `commitment` option is not specified, defaults to 'max' commitment.
 * @param {Connection} connection
 * @param {Transaction} transaction
 * @param {Array<Account>} signers
 * @param {ConfirmOptions} [options]
 * @returns {Promise<TransactionSignature>}
 */
declare function sendAndConfirmTransaction(
  connection: Connection,
  transaction: Transaction,
  signers: Array<Account>,
  options?: ConfirmOptions
): Promise<TransactionSignature>;

/**
 * Send and confirm a raw transaction
 *
 * If `commitment` option is not specified, defaults to 'max' commitment.
 * @param {Connection} connection
 * @param {Buffer} rawTransaction
 * @param {ConfirmOptions} [options]
 * @returns {Promise<TransactionSignature>}
 */
declare function sendAndConfirmRawTransaction(
  connection: Connection,
  rawTransaction: Buffer,
  options?: ConfirmOptions
): Promise<TransactionSignature>;
declare type Cluster = "devnet" | "testnet" | "mainnet-beta";
/**
 * Retrieves the RPC API URL for the specified cluster
 */
declare function clusterApiUrl(cluster?: Cluster, tls?: boolean): string;

/**
 * There are 1-billion lamports in one SOL
 */
declare var LAMPORTS_PER_SOL: any; // 1000000000
declare export {
  Account,
  Blockhash,
  BPF_LOADER_DEPRECATED_PROGRAM_ID,
  BPF_LOADER_PROGRAM_ID,
  BpfLoader,
  BLOCKHASH_CACHE_TIMEOUT_MS,
  RpcParams,
  TokenAccountsFilter,
  Context,
  SendOptions,
  ConfirmOptions,
  ConfirmedSignaturesForAddress2Options,
  RpcResponseAndContext,
  Commitment,
  LargestAccountsFilter,
  GetLargestAccountsConfig,
  SignatureStatusConfig,
  ContactInfo,
  VoteAccountInfo,
  VoteAccountStatus,
  InflationGovernor,
  EpochInfo,
  EpochSchedule,
  LeaderSchedule,
  Version,
  SimulatedTransactionResponse,
  ParsedInnerInstruction,
  TokenBalance,
  ParsedConfirmedTransactionMeta,
  CompiledInnerInstruction,
  ConfirmedTransactionMeta,
  ConfirmedTransaction,
  PartiallyDecodedInstruction,
  ParsedMessageAccount,
  ParsedInstruction,
  ParsedMessage,
  ParsedTransaction,
  ParsedConfirmedTransaction,
  ConfirmedBlock,
  PerfSample,
  Supply,
  TokenAmount,
  TokenAccountBalancePair,
  AccountBalancePair,
  GetConfirmedBlockRpcResult,
  SlotInfo,
  ParsedAccountData,
  StakeActivationData,
  AccountInfo,
  KeyedAccountInfo,
  AccountChangeCallback,
  ProgramAccountChangeCallback,
  SlotChangeCallback,
  SignatureResultCallback,
  SignatureStatusNotification,
  SignatureReceivedNotification,
  SignatureSubscriptionCallback,
  SignatureSubscriptionOptions,
  RootChangeCallback,
  Logs,
  LogsFilter,
  LogsCallback,
  SignatureResult,
  TransactionError,
  TransactionConfirmationStatus,
  SignatureStatus,
  ConfirmedSignatureInfo,
  Connection,
  FeeCalculatorLayout,
  FeeCalculator,
  Loader,
  MessageHeader,
  CompiledInstruction,
  MessageArgs,
  Message,
  NONCE_ACCOUNT_LENGTH,
  NonceAccount,
  MAX_SEED_LENGTH,
  PublicKey,
  STAKE_CONFIG_ID,
  Authorized,
  Lockup,
  CreateStakeAccountParams,
  CreateStakeAccountWithSeedParams,
  InitializeStakeParams,
  DelegateStakeParams,
  AuthorizeStakeParams,
  AuthorizeWithSeedStakeParams,
  SplitStakeParams,
  WithdrawStakeParams,
  DeactivateStakeParams,
  StakeInstruction,
  StakeInstructionType,
  STAKE_INSTRUCTION_LAYOUTS,
  StakeAuthorizationType,
  StakeAuthorizationLayout,
  StakeProgram,
  CreateAccountParams,
  TransferParams,
  AssignParams,
  CreateAccountWithSeedParams,
  CreateNonceAccountParams,
  CreateNonceAccountWithSeedParams,
  InitializeNonceParams,
  AdvanceNonceParams,
  WithdrawNonceParams,
  AuthorizeNonceParams,
  AllocateParams,
  AllocateWithSeedParams,
  AssignWithSeedParams,
  TransferWithSeedParams,
  SystemInstruction,
  SystemInstructionType,
  SYSTEM_INSTRUCTION_LAYOUTS,
  SystemProgram,
  CreateSecp256k1InstructionWithPublicKeyParams,
  CreateSecp256k1InstructionWithEthAddressParams,
  CreateSecp256k1InstructionWithPrivateKeyParams,
  Secp256k1Program,
  TransactionSignature,
  PACKET_DATA_SIZE,
  AccountMeta,
  TransactionInstructionCtorFields,
  SerializeConfig,
  TransactionInstruction,
  Transaction,
  VALIDATOR_INFO_KEY,
  Info,
  ValidatorInfo,
  VOTE_PROGRAM_ID,
  Lockout,
  EpochCredits,
  VoteAccount,
  SYSVAR_CLOCK_PUBKEY,
  SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
  SYSVAR_RENT_PUBKEY,
  SYSVAR_REWARDS_PUBKEY,
  SYSVAR_STAKE_HISTORY_PUBKEY,
  SYSVAR_INSTRUCTIONS_PUBKEY,
  sendAndConfirmTransaction,
  sendAndConfirmRawTransaction,
  Cluster,
  clusterApiUrl,
  LAMPORTS_PER_SOL,
};
